package tools;
import java_cup.runtime.Symbol;
import syntaxtree.*;

/* Preliminaries to use the scanner.  */
scan with {: Symbol tok = lexer.next_token(); System.out.println(tok); return tok; :};

parser code {: 
  JavaLex lexer;
  public Program p;
  public Parser(JavaLex lex) {
      super(lex);
      lexer = lex;

  }
:};
terminal String IDENT, OP;
terminal INT, BOOLEAN, STRING, TRUE, FALSE;
terminal Integer INT_LIT;
terminal PUBLIC, STATIC, VOID, MAIN, EXTENDS, IF, WHILE, SYSTEM, OUT, PRINTLN, CLASS, RETURN, NEW, ELSE, LENGTH, THIS;
terminal LBRACE, LSQBRACKET, LPAREN, RBRACE, RSQBRACKET, RPAREN, SEMICOLON;
terminal COMMA, PERIOD, EQUAL;
non terminal Program java_program;
non terminal Type type;
non terminal VarDecl var_decl;
non terminal VarDeclList var_decls;
non terminal MainClass main_class;
non terminal Exp exp;
non terminal ExpList exp_list, exp_rest;
non terminal Statement statement;
non terminal StatementList statements;
non terminal FormalList formal_list, formal_rests;
non terminal Formal formal_rest;
non terminal MethodDecl method_decl;
non terminal MethodDeclList method_decls;
non terminal ClassDecl class_decl;
non terminal ClassDeclList class_decls;

precedence left OP;
precedence left IDENT;
start with java_program;
java_program ::= main_class:m class_decls:cList
            {:RESULT = new Program(m, cList); this.parser.p = RESULT;:}
            ;
main_class  ::= CLASS IDENT:id1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LSQBRACKET RSQBRACKET IDENT:id2 RPAREN LBRACE statement:as RBRACE RBRACE
            {:RESULT = new MainClass(new Identifier(id1), new Identifier(id2), as);:}
            ;
class_decls ::= class_decl:c class_decls:cList
            {:cList.addElement(c); RESULT= cList;:}
            |
            {:RESULT = new ClassDeclList();:}
            ;
class_decl  ::= CLASS IDENT:id LBRACE var_decls:vList method_decls:mList RBRACE
            {:RESULT = new ClassDeclSimple(new Identifier(id), vList, mList);:}
            |   CLASS IDENT:id EXTENDS IDENT:id2 LBRACE var_decls:vList method_decls:mList RBRACE
            {:RESULT = new ClassDeclExtends(new Identifier(id), new Identifier(id2), vList, mList);:}
            ;
var_decls   ::= var_decls:curlist var_decl:item
            {:curlist.addElement(item); RESULT = curlist;:}
            |
            {:RESULT = new VarDeclList();:}
            ;
var_decl    ::= type:t IDENT:id SEMICOLON
            {:RESULT = new VarDecl(t, new Identifier(id));:}
            ;
method_decls::= method_decls:mList method_decl:m
            {:mList.addElement(m); RESULT = mList;:}
            |
            {:RESULT = new MethodDeclList();:}
            ;
method_decl ::= PUBLIC type:t IDENT:id LPAREN formal_list:fList RPAREN LBRACE var_decls:vList statements:sList RETURN exp:e SEMICOLON RBRACE
            {:RESULT = new MethodDecl(t, new Identifier(id), fList, vList, sList, e);:}
            ;
formal_list ::= type:t IDENT:id formal_rests:fList
            {:Formal f = new Formal(t,new Identifier(id)); fList.addElement(f); RESULT = fList;:}
            |
            {:RESULT = new FormalList();:}
            ;
formal_rests::= formal_rest:f formal_rests:fList
            {:fList.addElement(f); RESULT = fList;:}
            |
            {:RESULT = new FormalList();:}
            ;
formal_rest ::= COMMA type:t IDENT:id
            {:RESULT = new Formal(t, new Identifier(id));:}
            ;
type        ::= INT LSQBRACKET RSQBRACKET
                {:RESULT = new IntArrayType();:}
            |   BOOLEAN
                {:RESULT = new BooleanType();:}
            |   INT
                {:RESULT = new IntegerType();:}
            |   IDENT:id
                {:RESULT = new IdentifierType(id);:}
            ;
statements  ::= statements:sList statement:s
            {:sList.addElement(s); RESULT = sList;:}
            |
            {:RESULT = new StatementList();:}
            ;
statement   ::= LBRACE statements:sList RBRACE
            {:RESULT = new Block(sList);:}
            | IF LPAREN exp:e RPAREN statement:s ELSE statement:s2
            {:RESULT = new If(e, s, s2);:}
            |   WHILE LPAREN exp:e RPAREN statement:s
            {:RESULT = new While(e, s);:}
            |   SYSTEM PERIOD OUT PERIOD PRINTLN LPAREN exp:e RPAREN SEMICOLON
            {:RESULT = new Print(e);:}
            |   IDENT:id EQUAL exp:e SEMICOLON
            {:RESULT = new Assign(new Identifier(id), e);:}
            |   IDENT:id LSQBRACKET exp:e1 RSQBRACKET EQUAL exp:e2 SEMICOLON
            {:RESULT = new ArrayAssign(new Identifier(id), e1, e2); :}
            ;
exp         ::= exp:e1 OP:op exp:e2
            {:
            if(op.equalsIgnoreCase("and")){
                RESULT = new And(e1, e2);
            }
            else if(op.equalsIgnoreCase("minus")){
                RESULT = new Minus(e1, e2);
            }
            else if(op.equalsIgnoreCase("plus")){
                RESULT = new Plus(e1, e2);
            }
            else if(op.equalsIgnoreCase("<")){
                RESULT = new LessThan(e1, e2);
            }
            else if(op.equalsIgnoreCase("*")){
                RESULT = new Times(e1, e2);
            }
            else{
                System.out.println("NOT A REAL OP");
                System.exit(0);
            }
            :}
            | exp:e1 LSQBRACKET exp:e2 RSQBRACKET
            {:RESULT = new ArrayLookup(e1, e2);:}
            | exp:e PERIOD LENGTH
            {:RESULT = new ArrayLength(e);:}
            | exp:e PERIOD IDENT:id LPAREN exp_list:eList RPAREN
            {:RESULT = new Call(e, new Identifier(id), eList);:}
            | INT_LIT:ai
            {:RESULT = new IntegerLiteral(ai);:}
            | TRUE
            {:RESULT = new True();:}
            | FALSE
            {:RESULT = new False();:}
            | IDENT:id
            {:RESULT = new IdentifierExp(id);:}
            | THIS
            {:RESULT = new This();:}
            | NEW INT LSQBRACKET exp:e RSQBRACKET
            {:RESULT = new NewArray(e);:}
            | NEW IDENT:id LPAREN RPAREN
            {:RESULT = new NewObject(new Identifier(id)); :}
            ;
exp_list    ::= exp:e exp_rest:eList
            {:eList.addElement(e); RESULT = eList;:}
            ;
exp_rest    ::=  exp_rest:eList COMMA exp:e
            {:eList.addElement(e); RESULT = eList;:}
            |
            {:RESULT = new ExpList();:}
            ;
