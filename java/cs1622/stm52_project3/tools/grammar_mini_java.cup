package tools;
import java_cup.runtime.Symbol;
import syntaxtree.*;

/* Preliminaries to use the scanner.  */
scan with {: Symbol tok = lexer.next_token(); System.out.println(tok); return tok; :};

parser code {: 
  JavaLex lexer;
  public Parser(JavaLex lex) {
      super(lex);
      lexer = lex;

  }
:};
terminal String IDENT, OP;
terminal INT, BOOLEAN, STRING, TRUE, FALSE;
terminal Integer INT_LIT;
terminal PUBLIC, STATIC, VOID, MAIN, EXTENDS, IF, WHILE, SYSTEM, OUT, PRINTLN, CLASS, RETURN, NEW, ELSE, LENGTH, THIS;
terminal LBRACE, LSQBRACKET, LPAREN, RBRACE, RSQBRACKET, RPAREN, SEMICOLON;
terminal COMMA, PERIOD, EQUAL;
non terminal java_program;
non terminal class_decl, class_decls;
non terminal method_decl, method_decls;
non terminal formal_list, formal_rests, formal_rest;
non terminal statement, statements;
non terminal Type type;
non terminal VarDecl var_decl;
non terminal VarDeclList var_decls;
non terminal MainClass main_class;
non terminal Exp exp;
non terminal ExpList exp_list, exp_rest;

precedence left OP;
precedence left IDENT;
start with java_program;
java_program ::= main_class class_decls
            ;
main_class  ::= CLASS IDENT:id1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LSQBRACKET RSQBRACKET IDENT:id2 RPAREN LBRACE statements:as RBRACE RBRACE
            {:RESULT = new MainClass(new Identifier(id1), new Identifier(id2), as);:}
            ;
class_decls ::= class_decl class_decls
            |
            ;
class_decl  ::= CLASS IDENT LBRACE var_decls method_decls RBRACE
            |   CLASS IDENT EXTENDS IDENT LBRACE var_decls method_decls RBRACE
            ;
var_decls   ::= var_decl:item var_decls:curlist
            {:curlist.addElement(item); RESULT = curlist;:}
            |
            {:RESULT = new VarDeclList();:}
            ;
var_decl    ::= type:t IDENT:id SEMICOLON
            {:RESULT = new VarDecl(t, new Identifier(id));:}
            ;
method_decls::= method_decls method_decl
            |
            ;
method_decl ::= PUBLIC type IDENT LPAREN formal_list RPAREN LBRACE var_decls statements RETURN exp SEMICOLON RBRACE;
formal_list ::= type IDENT formal_rests
            |
            ;
formal_rests::= formal_rest formal_rests
            |
            ;
formal_rest ::= COMMA type IDENT
            ;
type        ::= INT LSQBRACKET RSQBRACKET
                {:RESULT = new IntArrayType();:}
            |   BOOLEAN
                {:RESULT = new BooleanType();:}
            |   INT
                {:RESULT = new IntegerType();:}
            |   IDENT:id
                {:RESULT = new IdentifierType(id);:}
            ;
statements  ::= statement statements
            |
            ;
statement   ::= LBRACE statements RBRACE
            |   IF LPAREN exp RPAREN statement ELSE statement
            |   WHILE LPAREN exp RPAREN statement
            |   SYSTEM PERIOD OUT PERIOD PRINTLN LPAREN exp RPAREN SEMICOLON
            |   IDENT EQUAL exp SEMICOLON
            |   IDENT LSQBRACKET exp RSQBRACKET EQUAL exp SEMICOLON
            ;
exp         ::= exp:e1 OP:op exp:e2
            {:
            if(op.equalsIgnoreCase("and")){
                RESULT = new And(e1, e2);
            }
            else if(op.equalsIgnoreCase("minus")){
                RESULT = new Minus(e1, e2);
            }
            else if(op.equalsIgnoreCase("plus")){
                RESULT = new Plus(e1, e2);
            }
            else if(op.equalsIgnoreCase("<")){
                RESULT = new LessThan(e1, e2);
            }
            else if(op.equalsIgnoreCase("*")){
                RESULT = new Times(e1, e2);
            }
            else{
                System.out.println("NOT A REAL OP");
                System.exit(0);
            }
            :}
            | exp:e1 LSQBRACKET exp:e2 RSQBRACKET
            {:RESULT = new ArrayLookup(e1, e2);:}
            | exp:e PERIOD LENGTH
            {:RESULT = new ArrayLength(e);:}
            | exp:e PERIOD IDENT:id LPAREN exp_list:eList RPAREN
            {:RESULT = new Call(e, new Identifier(id), eList);:}
            | INT_LIT:ai
            {:RESULT = new IntegerLiteral(ai);:}
            | TRUE
            {:RESULT = new True();:}
            | FALSE
            {:RESULT = new False();:}
            | IDENT:id
            {:RESULT = new IdentifierExp(id);:}
            | THIS
            {:RESULT = new This();:}
            | NEW INT LSQBRACKET exp:e RSQBRACKET
            {:RESULT = new NewArray(e);:}
            | NEW IDENT:id LPAREN RPAREN
            {:RESULT = new NewObject(new Identifier(id)); :}
            ;
exp_list    ::= exp:e exp_rest:eList
            {:eList.addElement(e); RESULT = eList;:}
            ;
exp_rest    ::= COMMA exp:e exp_rest:eList
            {:eList.addElement(e); RESULT = eList;:}
            |
            {:RESULT = new ExpList();:}
            ;
